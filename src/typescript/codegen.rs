use std::{
    collections::BTreeMap,
    fs,
    io::{self, Write},
    path::Path,
};

use fs_err::File;

use crate::{
    codegen::GroupedItem,
    data::SyncInput,
    typescript::ts_ast::{Comment, Expression, VariableDeclaration, VariableKind},
};

use super::ts_ast::{
    FunctionType, InterfaceDeclaration, ModifierToken, Parameter, PropertySignature, Statement,
    TypeReference,
};

const CODEGEN_HEADER: &str =
    "This file was generated by Tarmac. It is not intended for manual editing.";
const CODEGEN_IMAGE_SLICE_INTERFACE: &str = "ImageSlice";

pub fn perform_codegen(output_path: Option<&Path>, inputs: &[&SyncInput]) -> io::Result<()> {
    if let Some(path) = output_path {
        codegen_grouped(path, inputs)
    } else {
        codegen_individual(inputs)
    }
}

struct Prereqs<T> {
    prereq: Vec<Statement>,
    statement: T,
}
impl<T> Prereqs<T> {
    pub fn new(value: T) -> Prereqs<T> {
        Prereqs {
            prereq: vec![],
            statement: value,
        }
    }
}

type PrereqExpression = Prereqs<Expression>;

fn codegen_with_high_dpi_options(inputs: &BTreeMap<u32, &SyncInput>) -> Expression {
    let mut options_high_to_low = inputs.values().rev().peekable();
    let highest_dpi_option = options_high_to_low.next().unwrap();

    let expression = match (&highest_dpi_option.id, highest_dpi_option.slice) {
        (.., Some(..)) => Some(Expression::Identifier(CODEGEN_IMAGE_SLICE_INTERFACE.into())),
        (.., None) => Some(Expression::Identifier("string".into())),
    };

    let mut dpi_values = vec![];
    for (size, ..) in inputs {
        dpi_values.push(TypeReference::num(size.clone() as i32));
    }

    Expression::FunctionType(FunctionType::new(
        vec![Parameter::new(
            "dpiScale".into(),
            if dpi_values.len() > 0 {
                TypeReference::union(dpi_values)
            } else {
                TypeReference::id("number".into())
            },
        )],
        expression.unwrap(),
    ))
}

fn get_properties(item: &GroupedItem) -> (Vec<PropertySignature>, Vec<Statement>) {
    let mut prereqs: Vec<Statement> = Vec::new();
    let mut fields: Vec<PropertySignature> = Vec::new();

    match item {
        GroupedItem::Folder { children_by_name } => {
            for (name, child) in children_by_name {
                match child {
                    GroupedItem::Folder { .. } => {
                        let (properties, inner_prereqs) = get_properties(child);
                        for prereq in inner_prereqs {
                            prereqs.push(prereq);
                        }

                        let sanitized_name: String =
                            name.chars().filter(|c| c.is_alphanumeric()).collect();
                        let interface_name = format!("Folder_{}", sanitized_name);
                        let assets_interface =
                            InterfaceDeclaration::new(interface_name.clone(), None, properties);
                        prereqs.push(Statement::InterfaceDeclaration(assets_interface));

                        fields.push(PropertySignature::new(
                            name.clone(),
                            None,
                            Expression::Identifier(interface_name),
                        ));
                    }
                    GroupedItem::InputGroup {
                        inputs_by_dpi_scale,
                    } => {
                        if inputs_by_dpi_scale.len() == 1 {
                            let input = inputs_by_dpi_scale.values().next().unwrap();

                            let expression = match (&input.id, input.slice) {
                                (.., Some(..)) => Some(Expression::Identifier(
                                    CODEGEN_IMAGE_SLICE_INTERFACE.into(),
                                )),
                                (.., None) => Some(Expression::Identifier("string".into())),
                            };

                            fields.push(PropertySignature::new(
                                name.clone(),
                                None,
                                expression.unwrap(),
                            ));
                        } else {
                            fields.push(PropertySignature::new(
                                name.clone(),
                                None,
                                codegen_with_high_dpi_options(inputs_by_dpi_scale),
                            ));
                        }
                    }
                }
            }
        }
        GroupedItem::InputGroup {
            inputs_by_dpi_scale,
        } => {}
    }

    (fields, prereqs)
}

fn get_sprite_interface() -> Statement {
    Statement::InterfaceDeclaration(InterfaceDeclaration::new(
        CODEGEN_IMAGE_SLICE_INTERFACE.into(),
        None,
        vec![
            PropertySignature::new(
                "Image".into(),
                Some(vec![ModifierToken::Readonly]),
                Expression::Identifier("string".into()),
            ),
            PropertySignature::new(
                "ImageRectOffset".into(),
                Some(vec![ModifierToken::Readonly]),
                Expression::Identifier("Vector2".into()),
            ),
            PropertySignature::new(
                "ImageRectSize".into(),
                Some(vec![ModifierToken::Readonly]),
                Expression::Identifier("Vector2".into()),
            ),
        ],
    ))
}

/// Perform codegen for a group of inputs who have `codegen_path` defined.
///
/// We'll build up a Lua file containing nested tables that match the structure
/// of the input's path with its base path stripped away.
fn codegen_grouped(output_path: &Path, inputs: &[&SyncInput]) -> io::Result<()> {
    let declaration_path = output_path.parent().unwrap().join("index.d.ts");

    let should_generate_d_ts = inputs
        .iter()
        .find(|f| f.config.codegen_typescript_declaration);

    if should_generate_d_ts.is_none() {
        // Remove file if exists
        if declaration_path.exists() {
            fs::remove_file(declaration_path)?;
        }

        return Ok(());
    }

    let first = should_generate_d_ts.unwrap();

    let root_folder = GroupedItem::parse_root_folder(output_path, inputs);

    let root = &GroupedItem::Folder {
        children_by_name: root_folder,
    };

    let mut file = File::create(&declaration_path)?;
    write!(file, "{}", Comment::singleline(CODEGEN_HEADER.into()))?;

    let (properties, prereqs) = get_properties(&root);

    write!(file, "{}", get_sprite_interface())?;

    for prereq in prereqs {
        write!(file, "{}", prereq)?;
    }

    let interface_name = should_generate_d_ts
        .unwrap()
        .config
        .name
        .clone()
        .unwrap_or("TarmacAssets".into());

    let sanitized_name: String = interface_name
        .chars()
        .filter(|c| c.is_alphanumeric())
        .collect();

    let assets_interface = InterfaceDeclaration::new(sanitized_name.to_string(), None, properties);
    let export_assignment =
        Statement::export_assignment(Expression::Identifier(sanitized_name.to_string()));

    write!(
        file,
        "{}",
        Statement::list(vec![
            // interface TarmacAssets { ... }
            Statement::InterfaceDeclaration(assets_interface),
            Comment::multiline("*\n * Generated Tarmac Asset Interface\n *".into()),
            // declare const TarmacAssets: TarmacAssets
            VariableDeclaration::new(
                sanitized_name.to_string(),
                VariableKind::Const,
                Some(Expression::Identifier(sanitized_name.to_string())),
                Some(vec![ModifierToken::Declare]),
                None,
            ),
            // export = TarmacAssets;
            export_assignment,
        ])
    )?;

    Ok(())
}

/// Perform codegen for a group of inputs that don't have `codegen_path`
/// defined, and so generate individual files.
fn codegen_individual(inputs: &[&SyncInput]) -> io::Result<()> {
    for input in inputs {
        if !input.config.codegen_typescript_declaration {
            continue;
        }

        // let ast = Statement::Return(expression);

        let path = input.path.with_extension("d.ts");

        let mut file = File::create(path)?;
        writeln!(file, "{}", CODEGEN_HEADER)?;

        write!(
            file,
            "/** Tarmac Generated Asset Types */\n{}",
            VariableDeclaration::new(
                input.human_name(),
                VariableKind::Const,
                Some(Expression::Identifier("string".into())),
                Some(vec![ModifierToken::Declare]),
                None,
            )
        )?;

        write!(
            file,
            "{}",
            Statement::export_assignment(Expression::Identifier(input.human_name().into()))
        )?;
    }

    Ok(())
}
